<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.19.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ru" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Важность понимания парадигмы. RX для работы с API - Fateev.pro</title>
<meta name="description" content="Каждый день в нашей работе мы сталкиваемся с различными парадигмами. Не смотря на то, что большинство парадигм стары как мир (ООП, ФП и т.д.), часто всплывает что-то новое для нас. Возможно, что раньше мы не обращали внимание на них, или просто отсутствовала необходимость. Но теперь, когда она появилась, важно открыть свой разум, и освободить его от оков старых устоев. ">


  <meta name="author" content="Ivan Fateev">


<meta property="og:type" content="article">
<meta property="og:locale" content="ru">
<meta property="og:site_name" content="Fateev.pro">
<meta property="og:title" content="Важность понимания парадигмы. RX для работы с API">
<meta property="og:url" content="https://fateev.pro/ru/programming/understanding-paradigm-rx-for-api.html">


  <meta property="og:description" content="Каждый день в нашей работе мы сталкиваемся с различными парадигмами. Не смотря на то, что большинство парадигм стары как мир (ООП, ФП и т.д.), часто всплывает что-то новое для нас. Возможно, что раньше мы не обращали внимание на них, или просто отсутствовала необходимость. Но теперь, когда она появилась, важно открыть свой разум, и освободить его от оков старых устоев. ">



  <meta property="og:image" content="https://fateev.pro/imgs/paradigm-shift-graphic.jpg">





  <meta property="article:published_time" content="2018-10-12T07:00:00-05:00">





  

  


<link rel="canonical" href="https://fateev.pro/ru/programming/understanding-paradigm-rx-for-api.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Ivan Fateev",
      "url": "https://fateev.pro/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Fateev.pro Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


  
    <script src="/assets/js/headerPixels.js"></script>
  


    <!-- custom -->
<link rel="icon" type="image/png" href="/wp-content/uploads/2012/09/favicon.png">
<meta data-rh="true" property="al:android:app_name" content="Medium" />

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(16940533, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/16940533" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Fateev.pro
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/">Категории статей</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Теги</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">Обо мне</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Выпадающее меню</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/wp-content/uploads/2012/09/IMG_9760_final_bw-300x300.jpg" alt="Ivan Fateev" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Ivan Fateev</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Software engineer with more <br />than 10 years of experience</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Связаться со мной</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="https://github.com/PoisonousJohn" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/poisonousjohn/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
          
        
          
            <li><a href="https://teleg.run/poisonous_john" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-telegram" aria-hidden="true"></i> Telegram</a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Важность понимания парадигмы. RX для работы с API">
    <meta itemprop="description" content="Каждый день в нашей работе мы сталкиваемся с различными парадигмами. Не смотря на то, что большинство парадигм стары как мир (ООП, ФП и т.д.), часто всплывает что-то новое для нас. Возможно, что раньше мы не обращали внимание на них, или просто отсутствовала необходимость. Но теперь, когда она появилась, важно открыть свой разум, и освободить его от оков старых устоев.">
    <meta itemprop="datePublished" content="2018-10-12T07:00:00-05:00">
    

    <div class="page__inner-wrap">
        <header >
          <h1 id="page-title" class="page__title" itemprop="headline">Важность понимания парадигмы. RX для работы с API
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  10 мин на чтение

</p>
          
        </header>

      <section class="page__content" itemprop="text">
        
        <p><img src="/imgs/paradigm-shift-graphic.jpg" alt="Paradigm shift - A change from one way thinking to another" /></p>

<p>Каждый день в нашей работе мы сталкиваемся с различными парадигмами. Не смотря на то, что большинство парадигм стары как мир (ООП, ФП и т.д.), часто всплывает что-то новое для нас. Возможно, что раньше мы не обращали внимание на них, или просто отсутствовала необходимость. Но теперь, когда она появилась, важно открыть свой разум, и освободить его от оков старых устоев.</p>

<p>Когда мы изучаем что-то новое, бывает сложно перестроиться. Что такое парадигма? Это философия, образ мышления. Если его не понять, не придерживаться ему, то использование инструментов парадигмы становится бессмысленным.</p>

<p>С этой проблемой столкнулись С++ программисты, когда популярность Си стала угасать, и многие Сишные программисты ринулись покорять новый, более популярный, более сложный язык. Проблема была в том, что С++ использовали как Си с классами, не пытаясь постичь ООП, соответствующие паттерны, ну вы поняли мысль.</p>

<p>Хотя люди и получили новый инструмент, они просто не хотели менять свой образ мышления. Ведь для этого нужно многое переосмыслить, поменять образ мышления. Не все этого хотят, не все на это способны.</p>

<p>Это я все к чему. <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Парадигма реактивного программирования</a> становится все более популярной. Если вы еще не знакомы с ней, я очень советую познакомиться.</p>

<p>Я вижу, как библиотеку RX (для Unity это <a href="https://github.com/neuecc/UniRx">UniRx</a>) пользуют в разных проектах. В частности, один из вариантов использования – это обертка над API. Оно и понятно, благодаря RX можно удобно комбинировать запросы, реагировать на ошибки и тому подобное.</p>

<p>Давайте посмотрим на пример. Я буду писать на .Net Core и Rx.Net, но его можно легко транслировать на Unity и UniRx. Если вы знакомы с RX, то можете пропустить следующую секцию, и перейти к <a href="#understanding-paradigm">следующей части</a></p>

<h2 id="пример-работы-с-api-через-rxnet">Пример работы с API через RX.Net</h2>

<p>Итак, предположим, у нас есть некий интерфейс коммуникации с сервером.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reactive</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reactive.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Game.Models</span><span class="p">;</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">ILoginRepository</span> <span class="p">{</span>
    <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">);</span>
    <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="nf">GetUserSave</span><span class="p">(</span><span class="kt">string</span> <span class="n">token</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Здесь есть две простейшие операции: получить токен и получить сейв. Как правило, при старте игры мы получаем токен (если он протух или его не было), затем получаем сейв. В принципе это может быть объединено и в одну операцию. Но для демонстрации идеи я их разделил.</p>

<p>Методы возвращают IObservable, что означает, что операция асинхронна, и может занять какое-то время.</p>

<p>Сделаем простейшую заглушку для интерфейса.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reactive.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Game.Models</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LoginRepositoryStub</span> <span class="p">:</span> <span class="n">ILoginRepository</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="s">"stub_user_token"</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="nf">GetUserSave</span><span class="p">(</span><span class="kt">string</span> <span class="n">token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Observable</span>
                    <span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="k">new</span> <span class="nf">UserState</span><span class="p">())</span>
                    <span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
                    <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Здесь оба метода возвращают фиксированное значение с небольшой задержкой.</p>

<p>Обратите внимание, что здесь использован <code class="highlighter-rouge">SingleAsync</code>, который сразу закрывает стрим, после первого же события. Казалось бы, вполне логичное решение, ведь один запрос - один ответ.</p>

<p><code class="highlighter-rouge">UserState</code> пример класса сейва, просто для демонстрации.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">namespace</span> <span class="nn">Game.Models</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">UserState</span> <span class="p">{</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">cash</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Ну и теперь попробуем это завести.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reactive.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reactive</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">understanding_paradigm</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">ILoginRepository</span> <span class="n">loginRepository</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">LoginRepositoryStub</span><span class="p">();</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Started the program"</span><span class="p">);</span>
            <span class="kt">bool</span> <span class="n">exit</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetToken</span><span class="p">(</span><span class="s">"device id"</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got token: </span><span class="p">{</span><span class="n">token</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
                <span class="p">},</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got exception while getting the token: </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
                <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Finished getting the token"</span><span class="p">);</span>
                    <span class="n">exit</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="p">});</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Программа покажет следующий вывод:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started the program
Got token: stub_user_token
Finished getting the token
</code></pre></div></div>

<p>Пока что все ок. Теперь попробуем сэмулировать ошибку сервиса. Привожу только измененные части.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">LoginRepositoryStub</span> <span class="p">:</span> <span class="n">ILoginRepository</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;</span> <span class="n">getTokenHandler</span><span class="p">;</span>

    <span class="k">private</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ReturnToken</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="s">"user_stub_token"</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
                <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ReturnError</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="n">Throw</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Failed to get token"</span><span class="p">))</span>
                <span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
                <span class="p">.</span><span class="nf">SingleAsync</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">getTokenHandler</span> <span class="p">=</span> <span class="n">getTokenHandler</span> <span class="p">==</span> <span class="k">null</span>
                            <span class="p">?</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;)</span><span class="n">ReturnError</span>
                            <span class="p">:</span> <span class="n">ReturnToken</span><span class="p">;</span>

        <span class="k">return</span> <span class="nf">getTokenHandler</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>При первом запросе к GetToken возвращаю ошибку сервера. При втором, меняю имплементацию и возвращаю токен.</p>

<p>Запускаем программу, и видим, что она висит. Третье сообщение не выводится никогда.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started the program
Got exception while getting the token: System.Exception: Failed to get token
</code></pre></div></div>

<p>Одна из частых ошибок – люди не предусматривают обработку завершения стрима с ошибкой. В данном случае ошибка обработана (выведена в консоль), но выход из программы не осуществлен, так как onComplete не вызвался. В данном случае в <code class="highlighter-rouge">exit = false</code> достаточно перенести в Finally.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetToken</span><span class="p">(</span><span class="s">"device id"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">exit</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got token: </span><span class="p">{</span><span class="n">token</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got exception while getting the token: </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Finished getting the token"</span><span class="p">);</span>
    <span class="p">});</span></code></pre></figure>

<p>Теперь, обычная практика, добавить retry и таймаут, мало ли, может плохое соединение, и можно повторить запрос.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetToken</span><span class="p">(</span><span class="s">"device id"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Timeout</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">Retry</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">Finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">exit</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Finished getting the token"</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got token: </span><span class="p">{</span><span class="n">token</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got exception while getting the token: </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">});</span></code></pre></figure>

<p>Чтобы поддержать задержку ошибки, нужно немного изменить метод <code class="highlighter-rouge">ReturnError</code>:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ReturnError</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="s">"empty"</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">10</span><span class="p">))</span>
                <span class="p">.</span><span class="nf">SelectMany</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">Observable</span><span class="p">.</span><span class="n">Throw</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"failed to get token"</span><span class="p">)));</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Обратите внимание! Мы не можем сделать просто <code class="highlighter-rouge">Observable.Throw&lt;string&gt;(new Exception("error")).Delay(TimeSpan.FromSeconds(10)))</code>. В таком случае Delay не будет работать, так как ошибка прерывает стрим моментально. Поэтому здесь я комбинирую стрим через SelectMany. Так же мы не можем воспользоваться Observable.Empty, так как он тоже сразу закроет стрим.</p>
</blockquote>

<p>Оператор Retry организован таким образом, что при возникновении ошибки, он переподписывается на стрим. В текущей реализации логика в методе <code class="highlighter-rouge">GetLogin()</code> не будет вызвана при переподписке. Поэтому необходимо его обновить.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">observer</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"GetToken called"</span><span class="p">);</span>
        <span class="n">getTokenHandler</span> <span class="p">=</span> <span class="n">getTokenHandler</span> <span class="p">==</span> <span class="k">null</span>
                            <span class="p">?</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;)</span><span class="n">ReturnError</span>
                            <span class="p">:</span> <span class="n">ReturnToken</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">getTokenHandler</span><span class="p">().</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">observer</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre></figure>

<p>Здесь используется фабрика Observable.Create, которая будет вызывать функтор при каждой подписке. Таким образом мы можем быть уверены, что возвращаем разные результаты при Retry.</p>

<p>Запускаем программу:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started the program
GetToken called
GetToken called
GetToken called
Got exception while getting the token: System.TimeoutException: The operation has timed out.
Finished getting the token
</code></pre></div></div>

<p>GetToken вызвался трижды, при этом весь стрим завершился с ошибкой таймаута. Если мы изменим задержку на приемлемые значения, то увидим следующий вывод:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Started the program
GetToken called
GetToken called
Got token: user_stub_token
</code></pre></div></div>

<p>Прилеплять логику по ретраю и таймауту извне не красиво, поэтому мы можем перенести это в репозиторий.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="k">class</span> <span class="nc">APIRxExtensions</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">DEFAULT_TIMEOUT_SECS</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">DEFAULT_RETRY_COUNT</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">WrapWithRetryAndTimeout</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">observable</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">observable</span>
                <span class="p">.</span><span class="nf">Retry</span><span class="p">(</span><span class="n">DEFAULT_RETRY_COUNT</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Timeout</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="n">DEFAULT_TIMEOUT_SECS</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LoginRepositoryStub</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="n">observer</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"GetToken called"</span><span class="p">);</span>
            <span class="n">getTokenHandler</span> <span class="p">=</span> <span class="n">getTokenHandler</span> <span class="p">==</span> <span class="k">null</span>
                                <span class="p">?</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;)</span><span class="n">ReturnError</span>
                                <span class="p">:</span> <span class="n">ReturnToken</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">getTokenHandler</span><span class="p">().</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">observer</span><span class="p">);</span>
        <span class="p">}).</span><span class="nf">WrapWithRetryAndTimeout</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Ну и в конце, после авторизации, нам нужно получить UserState.</p>

<p>Таким образом, Retry и Timeout будут инкапсулированы в репозитории, и пользователю не нужно о них думать.</p>

<p>Финальный стрим будет выглядеть следующим образом:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="n">IDisposable</span> <span class="n">disposable</span> <span class="p">=</span> <span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetToken</span><span class="p">(</span><span class="s">"device id"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">SelectMany</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got token: </span><span class="p">{</span><span class="n">token</span><span class="p">}</span><span class="s">. Fetching user state"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetUserSave</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">state</span> <span class="p">=&gt;</span> <span class="p">{</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"state: "</span> <span class="p">+</span> <span class="n">state</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
                <span class="p">});</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">Finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">exit</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Finished getting the token"</span><span class="p">);</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">userState</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"User's cash: </span><span class="p">{</span><span class="n">userState</span><span class="p">.</span><span class="n">cash</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got exception while getting the state: </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Completed"</span><span class="p">);</span>
    <span class="p">});</span></code></pre></figure>

<h2 id="соблюдаем-философию-rx">Соблюдаем философию RX</h2>
<p><a name="understanding-paradigm"></a></p>

<p>Итак, давайте подведем краткие итоги. На данном этапе ясно, что RX позволяет легко и прозрачно внедрять логику вроде ретрая или таймаутов. В целом, логика работы с асинхрорнными операциями выглядит более стройно и понятно.</p>

<blockquote>
  <p>Пытливый ум читателя может заметить, что то же самое можно было бы сделать с помощью async/await, но не во всех версиях Unity/С# оно доступно, да и обработка ошибок, на мой взгляд, при таком подходе, не так прозрачна. В любом случае – решать вам.</p>
</blockquote>

<p>Давайте вернемся к началу статьи. Я сказал, что важно понимать парадигму, чтобы максимально извлекать из нее выгоду. Что в приведенном мною примере не так?</p>

<p>Реактивное программирование потому и называется реактивным, что весь код должен реагировать на события. Мы должны создавать все стримы событий заранее. Тогда мы будем уверены, что, когда прилетит событие, все обновится как надо.</p>

<p>В описанном же примере стрим “пассивный”. То есть посылка запроса происходит во время подписки на событие. Мы одновременно запрашиваем данные, и их читаем. Более того, такая подписка действую всего лишь один раз, из-за <code class="highlighter-rouge">SingleAsync</code>.</p>

<p>Это очень ограничивает варианты использования кода. Например, мы можем либо привязать код обновления к загрузке какого-либо вью, либо к кнопке “refresh”. Если нам нужны обновления в реальном времени, то мы делаем периодический refresh, что совсем не красиво.</p>

<p>Не смотря на то, что это естественно для REST API, это убивает всю гибкость и выгоду от RX.</p>

<p>В идеологии RX, запрос данных и реакция на событие об обновлении данных — две разные задачи, которые должны обрабатываться отдельно. Если вы знакомы с паттерном <a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel">MVVM</a>, то можете заметить, что в нем изменение модели и обновление вьюхи разделено. Обновление вью производится с помощью байндингов, которые реагируют на события. Изменение модели производится с помощью команд.</p>

<p>RX по сути требует такого же подхода. Как же это воплотить при работе с API?</p>

<h2 id="reactive-api">Reactive API</h2>

<p>Представим, что запрос данных — это команда в терминах MVVM. А ответы от API – это событие, которое может прикатить в любое время. Если мы их разделим, то все вьюхи при старте сразу могут подписаться на событие обновления, а мы можем быть уверены, что данные будут всегда акутальны.</p>

<p>Запросить же обновление данных мы можем из любого места программы. При этом, в отличие от предыдущего подхода, нам не нужно будет менять код обновления view. Да и вообще мы можем быть совершенно отвязаны от view.</p>

<p>Итак, интерфейс меняется следующим образом:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="nc">ILoginRepository</span> <span class="p">{</span>
    <span class="err">#</span><span class="n">region</span> <span class="n">commands</span>

    <span class="k">void</span> <span class="nf">fetchToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">);</span>
    <span class="k">void</span> <span class="nf">fetchUserSave</span><span class="p">(</span><span class="kt">string</span> <span class="n">token</span><span class="p">);</span>

    <span class="err">#</span><span class="n">endregion</span>

    <span class="err">#</span><span class="n">region</span> <span class="n">events</span>

    <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetTokenObservable</span><span class="p">();</span>
    <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="nf">GetUserSaveObservable</span><span class="p">();</span>

    <span class="err">#</span><span class="n">endregion</span>
<span class="p">}</span></code></pre></figure>

<p>По интерфейсу сразу понятно как данные запросить, и как подписаться на обновления.</p>

<p>Теперь к реализации.</p>

<p>Что я меняю первым делом – создаю отдельные Observable:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">LoginRepositoryStub</span> <span class="p">:</span> <span class="n">ILoginRepository</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">_tokenSubject</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="k">null</span><span class="p">);</span>
    <span class="k">private</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="n">_userStateSubject</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;(</span><span class="k">null</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>BehaviorSubject — классная штука. При подписке на него он сразу эммитит последнее известное ему onNext значение. Таким образом, если токен уже был получен, то подписчик будет обладать актуальным значением. Это такой своеобразный кэш.</p>

<p>Если в какой-то момент мы поймем, что токен надо обновить, то достаточно просто вызывать fetchToken() и все заинтересованные его получат.</p>

<p>Даже если нам необходимо периодическое обновление, то его легко сделать в одном месте по таймеру. Подписчиков может быть сколь угодно много.</p>

<p>Но это еще не все. Часто в приложениях нужен прямо таки настоящий реалтайм, когда сервер уведомляет клиент об изменениях. Например, с использованием сокетов. Если это ваш случай, то изменить код с REST API на сокеты элементарно. Все подписки остаются прежними. Меняется только транспорт: присоединяемся к сокету, и прокидываем событие в BehaviorSubject.</p>

<p>Важный момент: такой стрим не завершается никогда, при нормальных обстоятельствах. Если стрим закрылся, то это либо программа завершается, либо произошла ошибка. То есть, например, http ошибки прокидывать в этот стрим не нужно. Вся обработка ошибок должна уйти на другой слой логики.</p>

<p>Итак, давайте посмотрим как изменилась реализация с разделением кода.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">LoginRepositoryStub</span> <span class="p">:</span> <span class="n">ILoginRepository</span>
<span class="p">{</span>

    <span class="c1">// нужно учитывать, что при подписке может прийти null</span>
    <span class="k">private</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">_tokenSubject</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="k">null</span><span class="p">);</span>
    <span class="c1">// нужно учитывать, что при подписке может прийти null</span>
    <span class="k">private</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="n">_userStateSubject</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BehaviorSubject</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;(</span><span class="k">null</span><span class="p">);</span>

    <span class="k">private</span> <span class="n">Action</span> <span class="n">getTokenHandler</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">ReturnToken</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_tokenSubject</span><span class="p">.</span><span class="nf">OnNext</span><span class="p">(</span><span class="s">"user_stub_token"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetTokenObservable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_tokenSubject</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IObservable</span><span class="p">&lt;</span><span class="n">UserState</span><span class="p">&gt;</span> <span class="nf">GetUserSaveObservable</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_userStateSubject</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">fetchToken</span><span class="p">(</span><span class="kt">string</span> <span class="n">deviceId</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// вся логика работы с транспортом должна уйти на этот слой</span>
        <span class="n">Observable</span><span class="p">.</span><span class="nf">Timer</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">__</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="nf">ReturnToken</span><span class="p">();</span>
            <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">fetchUserSave</span><span class="p">(</span><span class="kt">string</span> <span class="n">token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// вся логика работы с транспортом должна уйти на этот слой</span>
        <span class="n">Observable</span><span class="p">.</span><span class="nf">Timer</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromSeconds</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">__</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="n">_userStateSubject</span><span class="p">.</span><span class="nf">OnNext</span><span class="p">(</span><span class="k">new</span> <span class="nf">UserState</span><span class="p">());</span>
            <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Здесь я сделал просто заглушку, которая присылает события с задержкой. Но на деле, в этом месте должен посылаться запрос и обрабатываться ошибки. Если пользователю нужно знать об ошибке, то нужно вывесить отдельный Observable с человекопонятным типом ошибки.</p>

<p>Теперь посмотрим на сам стрим.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Started the program"</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">exit</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">IDisposable</span> <span class="n">disposable</span> <span class="p">=</span> <span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetTokenObservable</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">Finally</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Closing token observable"</span><span class="p">);</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="n">token</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">token</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got token </span><span class="p">{</span><span class="n">token</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="n">loginRepository</span><span class="p">.</span><span class="nf">fetchUserSave</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="n">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Got exception while getting the token: </span><span class="p">{</span><span class="n">e</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">});</span>

    <span class="n">loginRepository</span><span class="p">.</span><span class="nf">GetUserSaveObservable</span><span class="p">()</span>
        <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">state</span> <span class="p">=&gt;</span> <span class="n">state</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">Subscribe</span><span class="p">(</span><span class="n">state</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"User's cash: </span><span class="p">{</span><span class="n">state</span><span class="p">.</span><span class="n">cash</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">});</span>

    <span class="n">loginRepository</span><span class="p">.</span><span class="nf">fetchToken</span><span class="p">(</span><span class="s">"device id"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(!</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Интересные моменты:</p>

<ol>
  <li>Теперь две отдельные подписки</li>
  <li>Подписки учитывают, что может прийти null, поэтому фильтруют ивенты</li>
  <li>Команды на запрос данных могут находиться в любом месте программы, как до подписки, так и после. Завязка на порядок вызова отсутствует.</li>
</ol>

<h2 id="подводим-итоги">Подводим итоги</h2>

<p>Фух, получилась довольно большая статья. Но основная мысль такова: недостаточно использовать парадигму, нужно полностью понять и принять ее философию. Если мы это не делаем, то сильно себя ограничиваем, тем самым теряя всю пользу от подхода.</p>

<p>Сделаю удобную работу с API можно и нужно. Если утилизировать возможность реактивности по максимуму, разделяя запросы и события, то код будет понятен и предсказуем.</p>

<p>Тем не менее, я хочу предостеречь о сложностях отладки RX стримов. когда что-то не работает, приходится повозится, зарываясь в дебрях колстека. Это один из негативных моментов работы с RX, да и ФП в целом.</p>

<p>Как всегда, если у вас есть мысли по теме — буду рад услышать. Комменты, или ПМ приветствуются.</p>

<p>Исходный код по теме <a href="https://github.com/PoisonousJohn/articles/tree/master/Telegram_Posts/understanding-paradigm">здесь</a>.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Метки: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/programming" class="page__taxonomy-item" rel="tag">Programming</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Разделы: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/programming" class="page__taxonomy-item" rel="tag">Programming</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Дата изменения:</strong> <time datetime="2018-10-12T07:00:00-05:00">October 12, 2018</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Поделиться</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%D0%92%D0%B0%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C+%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D1%8F+%D0%BF%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D1%8B.+RX+%D0%B4%D0%BB%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B+%D1%81+API%20https%3A%2F%2Ffateev.pro%2Fru%2Fprogramming%2Funderstanding-paradigm-rx-for-api.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Поделиться Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ffateev.pro%2Fru%2Fprogramming%2Funderstanding-paradigm-rx-for-api.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Поделиться Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Ffateev.pro%2Fru%2Fprogramming%2Funderstanding-paradigm-rx-for-api.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Поделиться LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/ru/gamedev/debug-tools.html" class="pagination--pager" title="Средства отладки
">Предыдущая</a>
    
    
      <a href="/ru/gamedev/independent-ui-layer.html" class="pagination--pager" title="Независимый UI слой — ускоряем разработку UI
">Следующая</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">Вам также может понравиться</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/bug-prioritization-matrix.png" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/en/startup-challenges/ensuring-the-quality-appium.html" rel="permalink">Startup challenges: Lost bugs, anxiety and burnout
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  6 мин на чтение

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Bugs in your company get lost in the chat, users leave, management blames engineers, engineers feel guilty and anxious, get burned out? We’ve been there. Her...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/testing-pyramid.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/en/startup-challenges/ensuring-the-quality-appium.html" rel="permalink">Startup challenges: Ensuring the quality with Appium
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 мин на чтение

</p>
    
    <p class="archive__item-excerpt" itemprop="description">One of the main challenges in our startup is to ensure that our product is of good quality. We decided to try Appium to test end-to-end scenarios.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/abstract-code.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/en/programming/how-to-clean-a-legacy-code-stop-complaining-start-doing.html" rel="permalink">How to clean a legacy code: stop complaining, start doing
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  7 мин на чтение

</p>
    
    <p class="archive__item-excerpt" itemprop="description">Most of the articles and books tell you how to write a “good code”. But in real life, you often find yourself deep in the shit after joining some company or ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/growing_junior.png" alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/ru/programming/are-you-growing-your-juniors-right.html" rel="permalink">Правильно ли вы растите своих джунов?
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  8 мин на чтение

</p>
    
    <p class="archive__item-excerpt" itemprop="description">У меня есть ученик. В начале его пути я помогал ему постичь наше ремесло, потом он попал в одну крупную компанию. Что с ним там сделали, вы не поверите…
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Связаться со мной:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> RSS-лента</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Ivan Fateev. Сайт работает на <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  
    <script src="/assets/js/main.min.js"></script>
  
    <script src="/assets/js/footerPixels.js"></script>
  
    <script src="https://kit.fontawesome.com/4eee35f757.js"></script>
  










  </body>
</html>
