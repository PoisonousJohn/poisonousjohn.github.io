---
id: 264
title: 'Smart pointers vs raw pointers; XCode: отладка undefined behaviour'
date: 2014-01-11T22:44:28+00:00


guid: http://fateev.me/?p=264
permalink: /c_plus_plus/smart-pointers-vs-raw-pointers-xcode-otladka-undefined-behaviour.html
dsq_thread_id:
  - "6600060489"
header:
  teaser:  /wp-content/uploads/2014/01/icon-lg-speed.png
categories:
  - C++
tags:
  - c++
  - gamedev
  - xcode
---
<h2>Скорость против удобства или Smart pointers не для игр</h2>
<img class="alignleft size-full wp-image-269" title="icon-lg-speed" src="http://fateev.me/wp-content/uploads/2014/01/icon-lg-speed.png" alt="" width="210" height="210" />

Очень много времени потратил на оптимизацию, все никак не мог понять, что же мне так сильно все тормозит, рендер вроде уже оптимизировал,

добрался до игровой механики. Проект - игра match3. Давно написал систему для match3 поля, ну и благополучно пользовался ей все это время. В свое время систему сделал на smart pointer'ах, чтобы особо не заморачиваться над жизненным циклом объектов, все работало как часы, пока не дошли до задач, где действительно много вычислений производится, профайлер показал, что довольно много времени уходит на alloc/dealloc shared pointer'ов, и я решил переписать всю систему на raw pointers.

Точнее, прежде чем переписать, я решил провести некоторые тесты, для чего я вытащил эту систему в отдельный проект и погонял ее сначала в том виде, в каком она работает в проекте, а затем переписал на raw pointers и снова проверил. Тест показал, что стало быстрее примерно в 2 раза. Значительная разница, учитывая, что в игре smart pointer'ы гоняются кучу раз в течение одного фрейма. И это еще учитывая, что я у них выключил thread safety.
<blockquote>Использовать smart pointer в игровых проектах стоит только в крайних случаях, да и то, лучше в тех местах, где нет активной работы с ним</blockquote>
<h2>Undefined behaviour: как сэкономить кучу времени</h2>
Довольный и преисполненный оптимизма, я перенес переписанную систему в проект, пришлось много где поменять куски кода на работу с raw pointers, но на этом дело не закончилось. Во первых, как  и любой человек, я допускаю ошибки, и при переходе на raw pointers возникали краши. Вот честно, я не знал как отлаживать undefined behaviour в XCode, я предполагал, что должна быть какая-нибудь утилита, в MS VS таких проблем нет, уже начал копать в сторону Valgrind, но потом подзабил и провозился со всем еще день, пока не застрял на месте, где ошибку ну совсем не мог выявить. Снова начал искать, и, слава Богу, наткнулся на stackoverflow на решение! Надеюсь кому-нибудь это поможет.

Итак, чтобы иметь возможность отслеживать доступ к уже освобожденной памяти, либо двойное удаление pointer'ов, ну и вообще следить за целостностью кучи, достаточно всего лишь отредактировать <strong>Scheme</strong> и установить галку "<strong>Enable Guard Malloc"</strong> на вкладке <strong>Diagnostics</strong>:

<a href="http://fateev.me/wp-content/uploads/2014/01/Снимок-экрана-2014-01-11-в-22.29.17.png"><img class="alignleft size-medium wp-image-266" title="Снимок экрана 2014-01-11 в 22.29.17" src="http://fateev.me/wp-content/uploads/2014/01/Снимок-экрана-2014-01-11-в-22.29.17-300x168.png" alt="" width="300" height="168" /></a>

<a href="http://fateev.me/wp-content/uploads/2014/01/Снимок-экрана-2014-01-11-в-22.29.28.png"><img class="alignleft size-medium wp-image-265" title="Снимок экрана 2014-01-11 в 22.29.28" src="http://fateev.me/wp-content/uploads/2014/01/Снимок-экрана-2014-01-11-в-22.29.28-300x203.png" alt="" width="300" height="203" /></a>

<strong><span style="color: #ff0000;">К сожалению, у данного метода есть свои ограничения, он будет работать на iOS только в симуляторе, но оно и понятно почему.</span></strong>

&nbsp;